This is a very early-stage project (alpha-version) + a set of experiments of building HAckable Text Input System (HATIS)

* Description
Text-editors are dead as a concept. What's needed is a text-input system. Mobile phones got it right more than 10 years ago. Both Android and iOS can catch the text-input context: «ah here we can input text, let's show the virtual keyboard!».

This project is inspired by very same idea: catch the text-input context globally (across all system, not just one process) and do what's needed: change the UI, keybindings, etc. Emacs got some part of text-input right with modes. But modes should be global, on Window Manager level (or even deeper).

In GUI it's possible to "catch input context" using Wayland::TextInputMethod.

It should also be possible on pure-tty with gettext or something.

The system should be very hackable. That's why it's written in lisp (Guile Scheme to interact with Guix System flawlessly).
* Dev Setup(s)
- Emacs + [[https://git.sr.ht/~abcdw/guile-ares-rs][Ares]]/[[xhttps://git.sr.ht/~abcdw/emacs-arei][Arei]]
- Guix System
- Gnome on Wayland as primary WM
- Sway launched in command line ("wm in a window"); from there I launch repl with ~bash repl.sh~ and I interact with it on Gnome with ~arei~

  You can also launch it on native sway but as I'm still experimenting with keyboard grabbing and "dangerous" stuff like this you might end up loosing the control completely and having to restart the machine.
* Notes
** On using ~guile-wayland~ listeners
ALL EVENTS MUST HAVE HANDLERS. Or will result eror «listener function for opcode 3 of ... is NULL».

It would be nice to create some form of wrapper that appends ~(lambda args #t)~ for all unhandled events [low priority]. FFI needed.
** ~input-popup-surface~ vs ~surface~ vs ~xdg-surface~
Input-popup-surface is another breed. Won't cast to any other.
** [[httphttps://github.com/swaywm/wlroots/blob/master/examples/input-method.c][input-method usage example from swaywm]]
* TODOS
** TODO Draft a simple GTK-based UI to show on text-input
The UI should be described as lisp data structure (xml?) and it should be possible to "resolve" it structure with different resolvers: gtk, qt, etc.
** TODO Stream keyboard events to fibers channel
** TODO Parse keyboard-events ~uint~ with ~guile-libxkbcommon~
** TODO Catch text-input context's surface (~get_input_popup_surface~)
I don't understand how helpfull is it not, but I bet it will be needed later to display proper custom UIs
** TODO Get ~app_id~ + ~pid~ & other meta from text-input context
There is no "unified" way of doing this in all Wayland implementationsthis because it's not Wayland's responsibility in general.

- sway: [[https://github.com/swaywm/sway/blob/master/swaymsg/main.c][swaymsg]]
** TODO Add start/pause/stop/restart option to the (main) loop
Currently when the repl is launched and the (main) in running it's not possible to eval any other expression. Only to interrupt the main loop and loose all the set parameters and context.

Guess it's
#+begin_src scheme
(while (wl-display-roundtrip (display)))
#+end_src
that spins this endless loop.
** TODO Also try [[https://wayland.app/protocols/xwayland-keyboard-grab-unstable-v1#zwp_xwayland_keyboard_grab_manager_v1:request:grab_keyboard][XWayland keyboard grabbing]] [low priority]
Alas it seems broken at it's very core:
#+begin_quote
The protocol:
- does not guarantee that the grab itself is applied for a surface, the grab request may be silently ignored by the compositor,
- does not guarantee that any events are sent to this client even if the grab is applied to a surface,
- does not guarantee that events sent to this client are exhaustive, a compositor may filter some events for its own consumption,
- does not guarantee that events sent to this client are continuous, a compositor may change and reroute keyboard events while the grab is nominally active.
#+end_quote
** DONE Use ~guile-ares~ intead of ~geiser~
See repl.sh
